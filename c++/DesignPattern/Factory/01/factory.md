
# Factory Pattern[完]
요약  
나는 new를 직접쓰고 싶지 않아요!

장점
1) 사용과 생성의 분리로 중복코드 정리 :  
생성과 관련된 역할을 하는 클래스를 별도로 두고 함수를 호출하여  
그 반환값을 이용한다.
2) 유연성, 확장성 개선 : 클래스의 명이 바뀌면 팩토리 클래스만 수정하면 된다.
3) 초기개발 단계에 유리 : 초기 개발단계에는 어떤 객체를 생성할지 모르기 때문에  
이와같이 한번에 객체 생성을 관리하는 클래스가 있으면 좋다.

단점
1) 아무튼 클래스의 생성을 위한 팩토리 클래스를 추가적으로 관리해야함.

-----------------------------------

## 1.2 의존
객체지향은 기능에 의해 분류하는 것
다시 말해 하나의 프로그램은 각 기능을 갖는 객체의 결합이다.
객체의 결합은 의존성을 갖는다.

### 1.2.1 객체지향  
### 1.2.2 의존  
### 1.2.3 객체선택  
### 1.2.4 강력한 결합  
### 1.2.5 클래스 변경  
팩토리패턴은 객체 생성 시 __확장과 수정__을 쉽게하기위한 설계 방법이다.
강력한 결합관계 : 객체를 고치면 나머지 여러부분도 고쳐야할 것이 생기면  
두 객체간 관계는 강력한 결합관계라고 하는 것이다.

```cpp
class A{
    ... new B();
}

class B{

}
```
이면 class B의 이름이 C로 바뀌면  
class A안에 new B를 new C로 바꿔줘야한다.
이를 보고 A와 B는 강력한 결합관계라고 할 수 있다.
결국 코드를 수정하고 변경하는데 힘들게 하는 것 --> 강력한 결합관계!


## 1.3의존성 주입

### 1.3.1 복합객체
객체가 다른 객체를 변수(필드)로 갖는 객체
복합객체는 다른 객체를 내부에서 직접 인스턴스화 할 수도 있지만
외부에서 인스턴스화한 객체를 함수의 인자로 받아서 사용할 수도 있다.

### 1.3.2 생성과 주입
의존성 주입 : 객체에 다른 객체의 정보를 전달하는 것  
외부에서 전달받은 객체를 내부 변수에 저장

-----------------------------------


## 1.4 의존 관계의 문제점

### 1.4.1 new 키워드
한 클래스에서 다른 클래스를 new 로 생성하는 것은 __강력한 결합관계__를 의미한다.

### 1.4.2 변화 대응
어떠한 코드도 절대 바뀌지 않는다는 보장은 할 수 없다.
일단 다른 객체를 사용하기 위해 생성하는 것 부터 __강력한 결합관계__를 동반하면 안돼겠지? --> 팩토리패턴!

### 1.4.3 생성 위임
쉽게 생각하자.
클래스가 다른 클래스를 사용하기위해 new를 사용하지 않는 방법을 고안한 것이다.
얼마나 다양한 객체들을 생성해야할지 모르니

객체 생성을 담당하는 특정 클래스를 하나 만드는 것이다. 이는 객체들의 생성하고 관리하는 캡슐화된 클래스를 선언하는 것이다.

즉,
객체B를 사용하려고 B를 생성하려는 클래스 A - 객체 요청 + 생성
에서
객체B를 사용하려는 클래스 A- 객체 요청
객체B를 생성하려는 클래스 C- 객체 생성
를 분리하여 

객체 A와 B의 강력한 결합관계를
객체 A가 C를 사용함으로써 B와의 관계를 느슨하게 하려는 것이다.

이렇게 클래스 C를 factory라고 한다.
객체 생서아고 캡슐화하여 위임하는 것

### 1.4.4 객체 공장
객체를 생성을 규격화함
규격화 방법
1) 클래스 분리 -> 기본 팩토리 패턴
2) 메서드 분리 -> 심플 팩토리 패턴


-----------------------------------

## 1.5 팩토리 패턴

### 1.5.1 느슨한 결합
객체 A가 B를 내부에서 생성하게될 경우
객체 A와 B의 강력한 결합관계를
객체 A가 C를 사용함으로써 B와의 관계를 느슨하게 하려는 것이다.

### 1.5.2 동적 팩토리
필요로하는 모든 객체의 생성을 factory class에 위임한다.
이를 통해 다른 class들은 다른 객체를 생성하기 위해 new를 사용하지 않아도 된다.

```cpp
#include <iostream>
using namespace std;

class Text
{
public:
    string printText()
    {
        return "안녕하세요";
    }
};

class Factory
{
public:
    static Text getInstance()
    {
        cout << "팩토리 객체를 생성하여 반환합니다." << endl;
        return Text();
    }
};

class Hello
{
    //class의 멤버로 auto 자료형 사용은 불가능하다.
public :
    string greeting()
    {
        auto h1 = Factory::getInstance();// 참고1
        return h1.printText();
    }

};

int main()
{
    Hello h1;
    cout << h1.greeting() << endl;

    return 0;
}
```
> 참고1  
Factory class의 getInstance()를 사용하기 위해  
new 키워드를 이용하여 팩토리 객체를 생성해야 한다.  
그렇지 않다면 getInstance()를 static으로 선언하여(=정적 타입) 호출하는 것이다.
Factory::getInstance() 가 만약 Hello 안에서 여러번 호출이 된다면  
Factory 객체를 매번 만들었다가 getInstance() 가 호출된 후 자동삭제 시켜줘야한다는 것인데
그 대신, static으로 선언하여 영구적으로 사용되게 하는 것!
이 경우 우리가 별도로 Factory 객체를 생성하지 않아도 Factory 객체 하나는 만들어지는 건가? 

### 1.5.3 클래스의 선택
자, 다시한번 생각해보면  
A -- 강한 결합 -- B  
에서  
A -- 느슨한 결합 -- C -- 강한결합 -- B  
A ------------느슨한 결합---------- B  
가 되는 것이다.  

A가 C에게 객체 생성을 '위임' 함으로써  
A-B 간 강한 결합도  
C-B 간 강한 결합으로 위임 되었다. 

### 1.5.4 형식 안정성
보통 type은 문자열을 사용한다.
그러므로 조건에 없는 잘못된 문자열을 기입하는 것을 방지하기위해 상수를 사용할 수도 있다.

-----------------------------------

## 1.6 simple factory pattern

### 1.6.1 메서드
Factory 클래스를 빼지 않고 해당 클래스 안에 직접 생성 factory 역할을 하는 메소드를 생성  
이 경우 강한 결합이지만 객체 생성에 관하여 한 곳에서 관리한다는 장점  
A+C ---- A` 를 만드는 느낌  

### 1.6.2 simple factory pattern
복잡하지 않고 굳이 클래스로 안빼고 써도 될 때
그리고 실제 많이 사용하는 패턴임

